/**
 * Voice.Assembly.FM Consolidated Server
 * Combines signaling server and static file serving in one process
 */

// Removed std/http/server import - using Deno.serve() for Deno Deploy compatibility
import { serveDir } from "std/http/file_server.ts";
import { STATUS_CODE } from "std/http/status.ts";

const port = parseInt(Deno.env.get("PORT") || "3456");

interface Peer {
  id: string;
  type: 'ctrl' | 'synth';
  socket: WebSocket;
  connectedAt: number;
}

interface PeerData {
  id: string;
  type: 'ctrl' | 'synth';
  serverId: string;
  connectedAt: number;
  lastSeen: number;
}

class SignalingServer {
  private peers = new Map<string, Peer>(); // Local WebSocket connections
  private rooms = new Map<string, Set<string>>(); // Local room cache for performance
  private kv: Deno.Kv;
  private serverId: string;
  private heartbeatInterval: number | null = null;

  constructor(kv: Deno.Kv) {
    this.kv = kv;
    this.serverId = crypto.randomUUID(); // Unique ID for this server instance
    console.log(`üéµ Voice.Assembly.FM Signaling Server starting... (Server ID: ${this.serverId})`);
    
    // Clean up stale data on startup
    this.cleanupOnStartup();
    
    // Start heartbeat to keep peers alive in KV
    this.startHeartbeat();
  }

  private async cleanupOnStartup() {
    // Clean up expired peers and stale room data
    await this.cleanupExpiredPeers();
    console.log(`üßπ Startup cleanup completed`);
  }

  private startHeartbeat() {
    // Update lastSeen for all local peers every 10 seconds
    this.heartbeatInterval = setInterval(async () => {
      for (const [peerId, peer] of this.peers) {
        try {
          await this.updatePeerLastSeen(peerId);
        } catch (error) {
          console.error(`‚ùå Failed to update heartbeat for peer ${peerId}:`, error);
        }
      }
      
      // Clean up expired peers (>30 seconds old)
      await this.cleanupExpiredPeers();
      
      // Poll and deliver cross-edge messages
      await this.pollAndDeliverMessages();
    }, 10000);
  }

  private async updatePeerLastSeen(peerId: string) {
    const existing = await this.kv.get<PeerData>(["peers", peerId]);
    if (existing.value) {
      await this.kv.set(["peers", peerId], {
        ...existing.value,
        lastSeen: Date.now()
      });
    }
  }

  private async cleanupExpiredPeers() {
    const entries = this.kv.list<PeerData>({ prefix: ["peers"] });
    const expireThreshold = Date.now() - 30000; // 30 seconds
    
    for await (const entry of entries) {
      if (entry.value.lastSeen < expireThreshold) {
        console.log(`üßπ Cleaning up expired peer: ${entry.value.id}`);
        await this.kv.delete(entry.key);
        
        // Also remove from rooms
        const roomEntries = this.kv.list({ prefix: ["rooms"] });
        for await (const roomEntry of roomEntries) {
          if (roomEntry.key[2] === entry.value.id) {
            await this.kv.delete(roomEntry.key);
          }
        }
      }
    }
  }

  private async pollAndDeliverMessages() {
    // Get all messages for locally connected peers
    for (const [peerId, peer] of this.peers) {
      const messagesIter = this.kv.list({ prefix: ["messages", peerId] });
      for await (const messageEntry of messagesIter) {
        const message = messageEntry.value as any;
        
        // Check if message has expired
        if (message.expiresAt && Date.now() > message.expiresAt) {
          await this.kv.delete(messageEntry.key);
          continue;
        }
        
        // Deliver message if peer is connected locally
        if (peer.socket.readyState === WebSocket.OPEN) {
          this.sendMessage(peer.socket, message);
          await this.kv.delete(messageEntry.key); // Clean up delivered message
        }
      }
    }
    
    // Clean up expired messages
    const allMessagesIter = this.kv.list({ prefix: ["messages"] });
    for await (const messageEntry of allMessagesIter) {
      const message = messageEntry.value as any;
      if (message.expiresAt && Date.now() > message.expiresAt) {
        await this.kv.delete(messageEntry.key);
      }
    }
  }

  handleWebSocket(socket: WebSocket) {
    let currentPeer: Peer | null = null;

    socket.addEventListener('open', () => {
      console.log('üì° WebSocket connection opened');
    });

    socket.addEventListener('message', async (event) => {
      try {
        const message = JSON.parse(event.data);
        const result = await this.handleMessage(socket, message, currentPeer);
        if (result) {
          currentPeer = result;
        }
      } catch (error) {
        console.error('‚ùå Invalid message format:', error);
        this.sendError(socket, 'Invalid message format');
      }
    });

    socket.addEventListener('close', () => {
      if (currentPeer) {
        console.log(`üîå Peer ${currentPeer.id} (${currentPeer.type}) disconnected`);
        this.removePeer(currentPeer.id).catch(console.error);
      }
    });

    socket.addEventListener('error', (error) => {
      console.error('‚ùå WebSocket error:', error);
      if (currentPeer) {
        this.removePeer(currentPeer.id).catch(console.error);
      }
    });
  }

  private async handleMessage(socket: WebSocket, message: any, currentPeer: Peer | null): Promise<Peer | null> {
    switch (message.type) {
      case 'join':
        return await this.handleJoin(socket, message);
      
      case 'offer':
      case 'answer':  
      case 'ice-candidate':
        await this.relaySignalingMessage(message, currentPeer);
        return currentPeer;
      
      case 'request-peers':
        await this.sendPeerList(socket, message.roomId);
        return currentPeer;

      default:
        console.warn('‚ö†Ô∏è Unknown message type:', message.type);
        this.sendError(socket, 'Unknown message type');
        return currentPeer;
    }
  }

  private async handleJoin(socket: WebSocket, message: any): Promise<Peer | null> {
    const { peerId, peerType, roomId, forceTakeover } = message;
    
    if (!peerId || !peerType || !roomId) {
      this.sendError(socket, 'Missing required fields: peerId, peerType, roomId');
      return null;
    }

    if (this.peers.has(peerId)) {
      this.sendError(socket, 'Peer ID already exists');
      return null;
    }

    // Check if room already has a ctrl client
    if (peerType === 'ctrl') {
      const existingCtrlPeers = await this.getPeersByType(roomId, 'ctrl');
      
      if (existingCtrlPeers.length > 0) {
        if (forceTakeover) {
          // Force takeover: kick existing ctrl client
          const existingCtrlId = existingCtrlPeers[0].id;
          console.log(`‚ö†Ô∏è Force takeover: Kicking existing ctrl ${existingCtrlId} for new ctrl ${peerId}`);
          
          // Check if the existing ctrl is connected to this server
          const existingLocalPeer = this.peers.get(existingCtrlId);
          if (existingLocalPeer) {
            // Send kicked message to existing ctrl
            this.sendMessage(existingLocalPeer.socket, {
              type: 'kicked',
              reason: 'Another control client has taken over',
              timestamp: Date.now()
            });
            
            // Close existing ctrl connection
            existingLocalPeer.socket.close();
          }
          
          // Remove from KV and local storage
          await this.removePeer(existingCtrlId);
          
          // Continue with new ctrl joining
        } else {
          // Normal mode: reject second ctrl
          this.sendError(socket, 'Room already has a control client');
          this.sendMessage(socket, {
            type: 'join-rejected',
            reason: 'Room already has a control client. Add ?force=true to URL to take over.',
            timestamp: Date.now()
          });
          return null;
        }
      }
    }

    const peer: Peer = {
      id: peerId,
      type: peerType as 'ctrl' | 'synth',
      socket,
      connectedAt: Date.now()
    };

    // Store peer locally (for WebSocket connection)
    this.peers.set(peerId, peer);
    
    // Store peer data in KV (for distributed access)
    const peerData: PeerData = {
      id: peerId,
      type: peerType as 'ctrl' | 'synth',
      serverId: this.serverId,
      connectedAt: Date.now(),
      lastSeen: Date.now()
    };
    
    try {
      await this.kv.set(["peers", peerId], peerData);
      await this.kv.set(["rooms", roomId, peerId], true);
      
      console.log(`‚úÖ Peer ${peerId} (${peerType}) joined room ${roomId} on server ${this.serverId}`);
      
      // Send confirmation
      this.sendMessage(socket, {
        type: 'join-success',
        peerId,
        timestamp: Date.now()
      });

      // Send peer list to the newly joined peer
      await this.sendPeerList(socket, roomId);
    } catch (error) {
      console.error('‚ùå Failed to store peer in KV:', error);
      this.sendError(socket, 'Failed to join room');
      return null;
    }

    // For star topology: notify based on peer type
    if (peerType === 'ctrl') {
      // Ctrl joining: notify all synths in room
      await this.notifyPeersByType(roomId, 'synth', {
        type: 'ctrl-available',
        ctrlId: peerId
      });
    } else if (peerType === 'synth') {
      // Synth joining: only notify ctrl peers
      await this.notifyPeersByType(roomId, 'ctrl', {
        type: 'synth-available', 
        synthId: peerId
      });
      
      // Send available ctrl to this synth
      const ctrlPeers = this.getPeersByType(roomId, 'ctrl');
      if (ctrlPeers.length > 0) {
        this.sendMessage(socket, {
          type: 'ctrl-available',
          ctrlId: ctrlPeers[0].id // Connect to first available ctrl
        });
      }
    }

    return peer;
  }

  private async relaySignalingMessage(message: any, fromPeer: Peer | null) {
    if (!fromPeer) {
      console.warn('‚ö†Ô∏è Received signaling message from unknown peer');
      return;
    }

    const { targetPeerId } = message;
    const targetPeer = this.peers.get(targetPeerId);
    
    // Add source peer ID to message
    const relayMessage = {
      ...message,
      fromPeerId: fromPeer.id
    };
    
    if (targetPeer) {
      // Target peer is connected locally - relay directly
      this.sendMessage(targetPeer.socket, relayMessage);
      console.log(`üì§ Relayed ${message.type} from ${fromPeer.id} to ${targetPeerId} (local)`);
    } else {
      // Check if target peer exists in KV (might be on another edge server)
      const peerResult = await this.kv.get(["peers", targetPeerId]);
      if (peerResult.value) {
        // Store message for cross-edge delivery
        await this.kv.set(["messages", targetPeerId, Date.now()], {
          ...relayMessage,
          timestamp: Date.now(),
          expiresAt: Date.now() + 10000 // 10 second TTL for signaling messages
        });
        console.log(`üì§ Queued ${message.type} from ${fromPeer.id} to ${targetPeerId} (cross-edge)`);
      } else {
        console.warn(`‚ö†Ô∏è Target peer ${targetPeerId} not found in distributed storage`);
      }
    }
  }

  private async sendPeerList(socket: WebSocket, roomId: string) {
    const peerList: any[] = [];
    const recentThreshold = Date.now() - 10000; // Only include peers active in last 10 seconds
    
    // Get locally connected peers in this room
    const roomPeers = this.rooms.get(roomId);
    if (roomPeers) {
      for (const peerId of roomPeers) {
        const peer = this.peers.get(peerId);
        if (peer) {
          peerList.push({
            id: peer.id,
            type: peer.type,
            connectedAt: peer.connectedAt
          });
        }
      }
    }
    
    // Also get peers from other edge servers in this room (only recent ones)
    const roomsIter = this.kv.list({ prefix: ["rooms", roomId] });
    for await (const roomEntry of roomsIter) {
      const [, , peerId] = roomEntry.key as [string, string, string];
      if (roomPeers?.has(peerId)) continue; // Already included locally
      
      // Get peer data from KV and check if it's recent
      const peerResult = await this.kv.get(["peers", peerId]);
      const peerData = peerResult.value as PeerData | null;
      if (peerData && peerData.lastSeen > recentThreshold) {
        peerList.push({
          id: peerData.id,
          type: peerData.type,
          connectedAt: peerData.connectedAt
        });
      }
    }

    console.log(`üìã Sending peer list to new peer: ${peerList.length} peers (${roomPeers?.size || 0} local, ${peerList.length - (roomPeers?.size || 0)} distributed)`);
    this.sendMessage(socket, {
      type: 'peer-list',
      peers: peerList
    });
  }

  private async broadcastToRoom(roomId: string, message: any, excludePeerId?: string) {
    // Get peers from local cache first for performance
    const roomPeers = this.rooms.get(roomId);
    if (roomPeers && roomPeers.size > 0) {
      for (const peerId of roomPeers) {
        if (peerId === excludePeerId) continue;
        
        const peer = this.peers.get(peerId);
        if (peer && peer.socket.readyState === WebSocket.OPEN) {
          this.sendMessage(peer.socket, message);
        }
      }
    }

    // Also broadcast to peers that might be connected to other edge servers
    const roomsIter = this.kv.list({ prefix: ["rooms", roomId] });
    for await (const roomEntry of roomsIter) {
      const [, , peerId] = roomEntry.key as [string, string, string];
      if (peerId === excludePeerId || roomPeers?.has(peerId)) continue;
      
      // Store message for cross-edge relay
      await this.kv.set(["messages", peerId, Date.now()], {
        ...message,
        timestamp: Date.now(),
        expiresAt: Date.now() + 5000 // 5 second TTL
      });
    }
  }

  private async notifyPeersByType(roomId: string, peerType: 'ctrl' | 'synth', message: any) {
    // Check local peers first
    const roomPeers = this.rooms.get(roomId);
    if (roomPeers) {
      for (const peerId of roomPeers) {
        const peer = this.peers.get(peerId);
        if (peer && peer.type === peerType && peer.socket.readyState === WebSocket.OPEN) {
          this.sendMessage(peer.socket, message);
        }
      }
    }

    // Also check for peers on other edge servers
    const roomsIter = this.kv.list({ prefix: ["rooms", roomId] });
    for await (const roomEntry of roomsIter) {
      const [, , peerId] = roomEntry.key as [string, string, string];
      if (roomPeers?.has(peerId)) continue; // Already handled locally
      
      // Get peer data to check type
      const peerResult = await this.kv.get(["peers", peerId]);
      const peer = peerResult.value as PeerData | null;
      if (peer && peer.type === peerType) {
        // Store message for cross-edge relay
        await this.kv.set(["messages", peerId, Date.now()], {
          ...message,
          timestamp: Date.now(),
          expiresAt: Date.now() + 5000 // 5 second TTL
        });
      }
    }
  }

  private async getPeersByType(roomId: string, peerType: 'ctrl' | 'synth'): Promise<PeerData[]> {
    const result: PeerData[] = [];
    
    // Get all peers in this room from KV
    const roomEntries = this.kv.list<boolean>({ prefix: ["rooms", roomId] });
    
    for await (const entry of roomEntries) {
      const peerId = entry.key[2] as string;
      const peerEntry = await this.kv.get<PeerData>(["peers", peerId]);
      
      if (peerEntry.value && peerEntry.value.type === peerType) {
        result.push(peerEntry.value);
      }
    }
    
    return result;
  }

  private async removePeer(peerId: string) {
    // Get peer data from KV
    const peerResult = await this.kv.get(["peers", peerId]);
    const peer = peerResult.value as PeerData | null;
    if (!peer) return;

    // Remove from KV storage
    await this.kv.delete(["peers", peerId]);

    // Remove from local cache
    this.peers.delete(peerId);

    // Get all rooms that contain this peer and remove from each
    const roomsIter = this.kv.list({ prefix: ["rooms"] });
    for await (const roomEntry of roomsIter) {
      const [, roomId, peerIdInRoom] = roomEntry.key as [string, string, string];
      if (peerIdInRoom === peerId) {
        // Remove peer from this room in KV
        await this.kv.delete(["rooms", roomId, peerId]);
        
        // Remove from local cache
        const roomPeers = this.rooms.get(roomId);
        if (roomPeers) {
          roomPeers.delete(peerId);
          
          // Notify remaining peers
          await this.broadcastToRoom(roomId, {
            type: 'peer-left',
            peerId,
            peerType: peer.type
          });

          // Clean up empty rooms
          if (roomPeers.size === 0) {
            this.rooms.delete(roomId);
          }
        }
      }
    }
  }

  private sendMessage(socket: WebSocket, message: any) {
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(message));
    }
  }

  private sendError(socket: WebSocket, error: string) {
    this.sendMessage(socket, {
      type: 'error',
      message: error,
      timestamp: Date.now()
    });
  }

  getStats() {
    return {
      totalPeers: this.peers.size,
      totalRooms: this.rooms.size,
      peersByType: {
        ctrl: Array.from(this.peers.values()).filter(p => p.type === 'ctrl').length,
        synth: Array.from(this.peers.values()).filter(p => p.type === 'synth').length
      }
    };
  }
}

// Get local IP addresses
function getLocalIPs() {
  const networkInterfaces = Deno.networkInterfaces();
  const ips = [];
  
  for (const iface of networkInterfaces) {
    if (iface.family === 'IPv4' && !iface.address.startsWith('127.') && iface.address !== '0.0.0.0') {
      ips.push(iface.address);
    }
  }
  
  return ips;
}

// HTTP Server with WebSocket upgrade and static file serving
async function handler(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const { pathname } = url;
  
  // Health check endpoint
  if (pathname === '/health') {
    return new Response(JSON.stringify(signalingServer.getStats()), {
      headers: { 'content-type': 'application/json' }
    });
  }

  // WebSocket upgrade
  if (pathname === '/ws') {
    const { socket, response } = Deno.upgradeWebSocket(req);
    signalingServer.handleWebSocket(socket);
    return response;
  }

  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 204,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type",
      }
    });
  }

  // Static file serving
  let response;
  
  // Route based on first path segment
  if (pathname.startsWith('/ctrl/')) {
    // Serve ctrl client - strip /ctrl prefix
    const relativePath = pathname.substring(5); // Remove '/ctrl'
    const newUrl = new URL(relativePath || '/', url.origin);
    const ctrlReq = new Request(newUrl.toString(), req);
    response = await serveDir(ctrlReq, { fsRoot: "public/ctrl" });
  } else if (pathname === '/ctrl') {
    // Redirect /ctrl to /ctrl/
    return new Response(null, {
      status: 302,
      headers: { 'Location': '/ctrl/' }
    });
  } else if (pathname.startsWith('/synth/')) {
    // Serve synth client - strip /synth prefix
    const relativePath = pathname.substring(6); // Remove '/synth'
    const newUrl = new URL(relativePath || '/', url.origin);
    const synthReq = new Request(newUrl.toString(), req);
    response = await serveDir(synthReq, { fsRoot: "public/synth" });
  } else if (pathname === '/synth') {
    // Redirect /synth to /synth/
    return new Response(null, {
      status: 302,
      headers: { 'Location': '/synth/' }
    });
  } else if (pathname.startsWith('/src/common/')) {
    // Serve shared modules from project root
    response = await serveDir(req, { fsRoot: "." });
  } else {
    // Default to serving a simple landing page
    return new Response(`
<!DOCTYPE html>
<html>
<head>
    <title>Voice.Assembly.FM</title>
    <style>
        body { 
            font-family: system-ui; 
            max-width: 600px; 
            margin: 50px auto; 
            padding: 20px;
            background: #000;
            color: #fff;
        }
        h1 { color: #00ff88; }
        a { color: #00ff88; text-decoration: none; }
        a:hover { text-decoration: underline; }
        .links { display: flex; gap: 20px; margin: 30px 0; }
        .link-box { 
            border: 1px solid #333; 
            padding: 20px; 
            border-radius: 8px;
            background: #111;
        }
    </style>
</head>
<body>
    <h1>üéµ Voice.Assembly.FM</h1>
    <p>Distributed vocal synthesis platform for audience-participatory electronic music performance.</p>
    
    <div class="links">
        <div class="link-box">
            <h3><a href="/ctrl/">Control Client</a></h3>
            <p>For the performer - controls timing and musical parameters</p>
        </div>
        <div class="link-box">
            <h3><a href="/synth/">Synth Client</a></h3>
            <p>For the audience - join the choir and participate in synthesis</p>
        </div>
    </div>
    
    <p><a href="/health">Health Check</a> | WebSocket: ws://[host]/ws</p>
</body>
</html>
    `, {
      headers: { 'content-type': 'text/html' }
    });
  }
  
  // Add CORS headers to all responses
  response.headers.set("Access-Control-Allow-Origin", "*");
  response.headers.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  response.headers.set("Access-Control-Allow-Headers", "Content-Type");
  
  // Fix MIME type for JavaScript modules
  if (pathname.endsWith('.js')) {
    response.headers.set("Content-Type", "application/javascript");
  }
  
  return response;
}

// Initialize Deno KV for distributed signaling
const kv = await Deno.openKv();
const signalingServer = new SignalingServer(kv);
const localIPs = getLocalIPs();

console.log("üåê Voice.Assembly.FM Consolidated Server");
console.log("=======================================");
console.log(`üì° Local:     http://localhost:${port}`);

if (localIPs.length > 0) {
  console.log("üì± Network:");
  localIPs.forEach(ip => {
    console.log(`   http://${ip}:${port}`);
  });
} else {
  console.log("‚ö†Ô∏è  No network interfaces found");
}

console.log("");
console.log("üéØ Quick Access:");
console.log(`   Ctrl Client:  http://localhost:${port}/ctrl/`);
console.log(`   Synth Client: http://localhost:${port}/synth/`);
console.log(`   Health Check: http://localhost:${port}/health`);
console.log(`   WebSocket:    ws://localhost:${port}/ws`);

if (localIPs.length > 0) {
  console.log("");
  console.log("üì± Network Access:");
  localIPs.forEach(ip => {
    console.log(`   Ctrl:  http://${ip}:${port}/ctrl/`);
    console.log(`   Synth: http://${ip}:${port}/synth/`);
  });
}

console.log("");
console.log("üé§ Quick Start:");
console.log("1. Open Ctrl Client ‚Üí Connect to Network");
console.log("2. Open Synth Client(s) ‚Üí Tap to Join the Choir");
console.log("3. Test calibration mode and audio controls");

// Use Deno.serve() for Deno Deploy compatibility
Deno.serve({ port, hostname: "0.0.0.0" }, handler);